{
  "language": "Solidity",
  "sources": {
    "contracts/RNGChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\nimport \"./RNGInterface.sol\";\n\ncontract RNGChainlink is RNGInterface, VRFConsumerBase, Ownable {\n  event KeyHashSet(bytes32 keyHash);\n  event FeeSet(uint256 fee);\n  event VrfCoordinatorSet(address indexed vrfCoordinator);\n  event VRFRequested(uint256 indexed requestId, bytes32 indexed chainlinkRequestId);\n\n  /// @dev The keyhash used by the Chainlink VRF\n  bytes32 public keyHash;\n\n  /// @dev The request fee of the Chainlink VRF\n  uint256 public fee;\n\n  /// @dev A counter for the number of requests made used for request ids\n  uint32 public requestCount;\n\n  /// @dev A list of random numbers from past requests mapped by request id\n  mapping(uint32 => uint256) internal randomNumbers;\n\n  /// @dev A list of blocks to be locked at based on past requests mapped by request id\n  mapping(uint32 => uint32) internal requestLockBlock;\n\n  /// @dev A mapping from Chainlink request ids to internal request ids\n  mapping(bytes32 => uint32) internal chainlinkRequestIds;\n\n  /// @dev Public constructor\n  constructor(address _vrfCoordinator, address _link) VRFConsumerBase(_vrfCoordinator, _link) {\n    emit VrfCoordinatorSet(_vrfCoordinator);\n  }\n\n  function getLink() external view returns (address) {\n    return address(LINK);\n  }\n\n  /// @notice Allows governance to set the VRF keyhash\n  /// @param _keyhash The keyhash to be used by the VRF\n  function setKeyhash(bytes32 _keyhash) external onlyOwner {\n    keyHash = _keyhash;\n\n    emit KeyHashSet(keyHash);\n  }\n\n  /// @notice Allows governance to set the fee per request required by the VRF\n  /// @param _fee The fee to be charged for a request\n  function setFee(uint256 _fee) external onlyOwner {\n    fee = _fee;\n\n    emit FeeSet(fee);\n  }\n\n  /// @notice Gets the last request id used by the RNG service\n  /// @return requestId The last request id used in the last request\n  function getLastRequestId() external view override returns (uint32 requestId) {\n    return requestCount;\n  }\n\n  /// @notice Gets the Fee for making a Request against an RNG service\n  /// @return feeToken The address of the token that is used to pay fees\n  /// @return requestFee The fee required to be paid to make a request\n  function getRequestFee() external view override returns (address feeToken, uint256 requestFee) {\n    return (address(LINK), fee);\n  }\n\n  /// @notice Sends a request for a random number to the 3rd-party service\n  /// @dev Some services will complete the request immediately, others may have a time-delay\n  /// @dev Some services require payment in the form of a token, such as $LINK for Chainlink VRF\n  /// @return requestId The ID of the request used to get the results of the RNG service\n  /// @return lockBlock The block number at which the RNG service will start generating time-delayed randomness.  The calling contract\n  /// should \"lock\" all activity until the result is available via the `requestId`\n  function requestRandomNumber() external override returns (uint32 requestId, uint32 lockBlock) {\n    lockBlock = uint32(block.number);\n\n    // collect fee for payment\n    require(LINK.transferFrom(msg.sender, address(this), fee), \"RNGChainlink/fee-transfer-failed\");\n\n    // send request (costs fee)\n    requestId = _requestRandomness();\n\n    requestLockBlock[requestId] = lockBlock;\n\n    emit RandomNumberRequested(requestId, msg.sender);\n  }\n\n  /// @notice Checks if the request for randomness from the 3rd-party service has completed\n  /// @dev For time-delayed requests, this function is used to check/confirm completion\n  /// @param requestId The ID of the request used to get the results of the RNG service\n  /// @return isCompleted True if the request has completed and a random number is available, false otherwise\n  function isRequestComplete(uint32 requestId) external view override returns (bool isCompleted) {\n    return randomNumbers[requestId] != 0;\n  }\n\n  /// @notice Gets the random number produced by the 3rd-party service\n  /// @param requestId The ID of the request used to get the results of the RNG service\n  /// @return randomNum The random number\n  function randomNumber(uint32 requestId) external view override returns (uint256 randomNum) {\n    return randomNumbers[requestId];\n  }\n\n  /// @dev Requests a new random number from the Chainlink VRF\n  /// @dev The result of the request is returned in the function `fulfillRandomness`\n  function _requestRandomness() internal returns (uint32 requestId) {\n    // Get next request ID\n    requestId = _getNextRequestId();\n\n    // Complete request\n    bytes32 vrfRequestId = requestRandomness(keyHash, fee);\n    chainlinkRequestIds[vrfRequestId] = requestId;\n\n    emit VRFRequested(requestId, vrfRequestId);\n  }\n\n  /// @notice Callback function used by VRF Coordinator\n  /// @dev The VRF Coordinator will only send this function verified responses.\n  /// @dev The VRF Coordinator will not pass randomness that could not be verified.\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n    uint32 internalRequestId = chainlinkRequestIds[requestId];\n\n    // Store random value\n    randomNumbers[internalRequestId] = randomness;\n\n    emit RandomNumberCompleted(internalRequestId, randomness);\n  }\n\n  /// @dev Gets the next consecutive request ID to be used\n  /// @return requestId The ID to be used for the next request\n  function _getNextRequestId() internal returns (uint32 requestId) {\n    requestCount++;\n    requestId = requestCount;\n  }\n}\n"
    },
    "contracts/RNGInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\n/**\n * @title Random Number Generator Interface\n * @notice Provides an interface for requesting random numbers from 3rd-party RNG services (Chainlink VRF, Starkware VDF, etc..)\n */\ninterface RNGInterface {\n  /**\n   * @notice Emitted when a new request for a random number has been submitted\n   * @param requestId The indexed ID of the request used to get the results of the RNG service\n   * @param sender The indexed address of the sender of the request\n   */\n  event RandomNumberRequested(uint32 indexed requestId, address indexed sender);\n\n  /**\n   * @notice Emitted when an existing request for a random number has been completed\n   * @param requestId The indexed ID of the request used to get the results of the RNG service\n   * @param randomNumber The random number produced by the 3rd-party service\n   */\n  event RandomNumberCompleted(uint32 indexed requestId, uint256 randomNumber);\n\n  /**\n   * @notice Gets the last request id used by the RNG service\n   * @return requestId The last request id used in the last request\n   */\n  function getLastRequestId() external view returns (uint32 requestId);\n\n  /**\n   * @notice Gets the Fee for making a Request against an RNG service\n   * @return feeToken The address of the token that is used to pay fees\n   * @return requestFee The fee required to be paid to make a request\n   */\n  function getRequestFee() external view returns (address feeToken, uint256 requestFee);\n\n  /**\n   * @notice Sends a request for a random number to the 3rd-party service\n   * @dev Some services will complete the request immediately, others may have a time-delay\n   * @dev Some services require payment in the form of a token, such as $LINK for Chainlink VRF\n   * @return requestId The ID of the request used to get the results of the RNG service\n   * @return lockBlock The block number at which the RNG service will start generating time-delayed randomness.\n   * The calling contract should \"lock\" all activity until the result is available via the `requestId`\n   */\n  function requestRandomNumber() external returns (uint32 requestId, uint32 lockBlock);\n\n  /**\n   * @notice Checks if the request for randomness from the 3rd-party service has completed\n   * @dev For time-delayed requests, this function is used to check/confirm completion\n   * @param requestId The ID of the request used to get the results of the RNG service\n   * @return isCompleted True if the request has completed and a random number is available, false otherwise\n   */\n  function isRequestComplete(uint32 requestId) external view returns (bool isCompleted);\n\n  /**\n   * @notice Gets the random number produced by the 3rd-party service\n   * @param requestId The ID of the request used to get the results of the RNG service\n   * @return randomNum The random number\n   */\n  function randomNumber(uint32 requestId) external returns (uint256 randomNum);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash] + 1;\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface internal immutable LINK;\n  address private immutable vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\n    private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(address _vrfCoordinator, address _link) {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "contracts/RNGChainlinkV2Interface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\n\nimport \"./RNGInterface.sol\";\n\n/**\n * @title RNG Chainlink V2 Interface\n * @notice Provides an interface for requesting random numbers from Chainlink VRF V2.\n */\ninterface RNGChainlinkV2Interface is RNGInterface {\n  /**\n   * @notice Get Chainlink VRF keyHash associated with this contract.\n   * @return bytes32 Chainlink VRF keyHash\n   */\n  function getKeyHash() external view returns (bytes32);\n\n  /**\n   * @notice Get Chainlink VRF subscription id associated with this contract.\n   * @return uint64 Chainlink VRF subscription id\n   */\n  function getSubscriptionId() external view returns (uint64);\n\n  /**\n   * @notice Get Chainlink VRF coordinator contract address associated with this contract.\n   * @return address Chainlink VRF coordinator address\n   */\n  function getVrfCoordinator() external view returns (VRFCoordinatorV2Interface);\n\n  /**\n   * @notice Set Chainlink VRF keyHash.\n   * @dev This function is only callable by the owner.\n   * @param keyHash Chainlink VRF keyHash\n   */\n  function setKeyhash(bytes32 keyHash) external;\n\n  /**\n   * @notice Set Chainlink VRF subscription id associated with this contract.\n   * @dev This function is only callable by the owner.\n   * @param subscriptionId Chainlink VRF subscription id\n   */\n  function setSubscriptionId(uint64 subscriptionId) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n}\n"
    },
    "contracts/RNGChainlinkV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@pooltogether/owner-manager-contracts/contracts/Manageable.sol\";\n\nimport \"./RNGChainlinkV2Interface.sol\";\n\ncontract RNGChainlinkV2 is RNGChainlinkV2Interface, VRFConsumerBaseV2, Manageable {\n  /* ============ Global Variables ============ */\n\n  /// @dev Reference to the VRFCoordinatorV2 deployed contract\n  VRFCoordinatorV2Interface internal vrfCoordinator;\n\n  /// @dev A counter for the number of requests made used for request ids\n  uint32 internal requestCounter;\n\n  /// @dev Chainlink VRF subscription id\n  uint64 internal subscriptionId;\n\n  /// @dev Hash of the public key used to verify the VRF proof\n  bytes32 internal keyHash;\n\n  /// @dev A list of random numbers from past requests mapped by request id\n  mapping(uint32 => uint256) internal randomNumbers;\n\n  /// @dev A list of blocks to be locked at based on past requests mapped by request id\n  mapping(uint32 => uint32) internal requestLockBlock;\n\n  /// @dev A mapping from Chainlink request ids to internal request ids\n  mapping(uint256 => uint32) internal chainlinkRequestIds;\n\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when the Chainlink VRF keyHash is set\n   * @param keyHash Chainlink VRF keyHash\n   */\n  event KeyHashSet(bytes32 keyHash);\n\n  /**\n   * @notice Emitted when the Chainlink VRF subscription id is set\n   * @param subscriptionId Chainlink VRF subscription id\n   */\n  event SubscriptionIdSet(uint64 subscriptionId);\n\n  /**\n   * @notice Emitted when the Chainlink VRF Coordinator address is set\n   * @param vrfCoordinator Address of the VRF Coordinator\n   */\n  event VrfCoordinatorSet(VRFCoordinatorV2Interface indexed vrfCoordinator);\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice Constructor of the contract\n   * @param _owner Owner of the contract\n   * @param _vrfCoordinator Address of the VRF Coordinator\n   * @param _subscriptionId Chainlink VRF subscription id\n   * @param _keyHash Hash of the public key used to verify the VRF proof\n   */\n  constructor(\n    address _owner,\n    VRFCoordinatorV2Interface _vrfCoordinator,\n    uint64 _subscriptionId,\n    bytes32 _keyHash\n  ) Ownable(_owner) VRFConsumerBaseV2(address(_vrfCoordinator)) {\n    _setVRFCoordinator(_vrfCoordinator);\n    _setSubscriptionId(_subscriptionId);\n    _setKeyhash(_keyHash);\n  }\n\n  /* ============ External Functions ============ */\n\n  /// @inheritdoc RNGInterface\n  function requestRandomNumber()\n    external\n    override\n    onlyManager\n    returns (uint32 requestId, uint32 lockBlock)\n  {\n    uint256 _vrfRequestId = vrfCoordinator.requestRandomWords(\n      keyHash,\n      subscriptionId,\n      3,\n      1000000,\n      1\n    );\n\n    requestCounter++;\n    uint32 _requestCounter = requestCounter;\n\n    requestId = _requestCounter;\n    chainlinkRequestIds[_vrfRequestId] = _requestCounter;\n\n    lockBlock = uint32(block.number);\n    requestLockBlock[_requestCounter] = lockBlock;\n\n    emit RandomNumberRequested(_requestCounter, msg.sender);\n  }\n\n  /// @inheritdoc RNGInterface\n  function isRequestComplete(uint32 _internalRequestId)\n    external\n    view\n    override\n    returns (bool isCompleted)\n  {\n    return randomNumbers[_internalRequestId] != 0;\n  }\n\n  /// @inheritdoc RNGInterface\n  function randomNumber(uint32 _internalRequestId)\n    external\n    view\n    override\n    returns (uint256 randomNum)\n  {\n    return randomNumbers[_internalRequestId];\n  }\n\n  /// @inheritdoc RNGInterface\n  function getLastRequestId() external view override returns (uint32 requestId) {\n    return requestCounter;\n  }\n\n  /// @inheritdoc RNGInterface\n  function getRequestFee() external pure override returns (address feeToken, uint256 requestFee) {\n    return (address(0), 0);\n  }\n\n  /// @inheritdoc RNGChainlinkV2Interface\n  function getKeyHash() external view override returns (bytes32) {\n    return keyHash;\n  }\n\n  /// @inheritdoc RNGChainlinkV2Interface\n  function getSubscriptionId() external view override returns (uint64) {\n    return subscriptionId;\n  }\n\n  /// @inheritdoc RNGChainlinkV2Interface\n  function getVrfCoordinator() external view override returns (VRFCoordinatorV2Interface) {\n    return vrfCoordinator;\n  }\n\n  /// @inheritdoc RNGChainlinkV2Interface\n  function setSubscriptionId(uint64 _subscriptionId) external override onlyOwner {\n    _setSubscriptionId(_subscriptionId);\n  }\n\n  /// @inheritdoc RNGChainlinkV2Interface\n  function setKeyhash(bytes32 _keyHash) external override onlyOwner {\n    _setKeyhash(_keyHash);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Callback function called by VRF Coordinator\n   * @dev The VRF Coordinator will only call it once it has verified the proof associated with the randomness.\n   * @param _vrfRequestId Chainlink VRF request id\n   * @param _randomWords Chainlink VRF array of random words\n   */\n  function fulfillRandomWords(uint256 _vrfRequestId, uint256[] memory _randomWords)\n    internal\n    override\n  {\n    uint32 _internalRequestId = chainlinkRequestIds[_vrfRequestId];\n    require(_internalRequestId > 0, \"RNGChainLink/requestId-incorrect\");\n\n    uint256 _randomNumber = _randomWords[0];\n    randomNumbers[_internalRequestId] = _randomNumber;\n\n    emit RandomNumberCompleted(_internalRequestId, _randomNumber);\n  }\n\n  /**\n   * @notice Set Chainlink VRF coordinator contract address.\n   * @param _vrfCoordinator Chainlink VRF coordinator contract address\n   */\n  function _setVRFCoordinator(VRFCoordinatorV2Interface _vrfCoordinator) internal {\n    require(address(_vrfCoordinator) != address(0), \"RNGChainLink/vrf-not-zero-addr\");\n    vrfCoordinator = _vrfCoordinator;\n    emit VrfCoordinatorSet(_vrfCoordinator);\n  }\n\n  /**\n   * @notice Set Chainlink VRF subscription id associated with this contract.\n   * @param _subscriptionId Chainlink VRF subscription id\n   */\n  function _setSubscriptionId(uint64 _subscriptionId) internal {\n    require(_subscriptionId > 0, \"RNGChainLink/subId-gt-zero\");\n    subscriptionId = _subscriptionId;\n    emit SubscriptionIdSet(_subscriptionId);\n  }\n\n  /**\n   * @notice Set Chainlink VRF keyHash.\n   * @param _keyHash Chainlink VRF keyHash\n   */\n  function _setKeyhash(bytes32 _keyHash) internal {\n    require(_keyHash != bytes32(0), \"RNGChainLink/keyHash-not-empty\");\n    keyHash = _keyHash;\n    emit KeyHashSet(_keyHash);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "@pooltogether/owner-manager-contracts/contracts/Manageable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @title Abstract manageable contract that can be inherited by other contracts\n * @notice Contract module based on Ownable which provides a basic access control mechanism, where\n * there is an owner and a manager that can be granted exclusive access to specific functions.\n *\n * By default, the owner is the deployer of the contract.\n *\n * The owner account is set through a two steps process.\n *      1. The current `owner` calls {transferOwnership} to set a `pendingOwner`\n *      2. The `pendingOwner` calls {acceptOwnership} to accept the ownership transfer\n *\n * The manager account needs to be set using {setManager}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyManager`, which can be applied to your functions to restrict their use to\n * the manager.\n */\nabstract contract Manageable is Ownable {\n    address private _manager;\n\n    /**\n     * @dev Emitted when `_manager` has been changed.\n     * @param previousManager previous `_manager` address.\n     * @param newManager new `_manager` address.\n     */\n    event ManagerTransferred(address indexed previousManager, address indexed newManager);\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Gets current `_manager`.\n     * @return Current `_manager` address.\n     */\n    function manager() public view virtual returns (address) {\n        return _manager;\n    }\n\n    /**\n     * @notice Set or change of manager.\n     * @dev Throws if called by any account other than the owner.\n     * @param _newManager New _manager address.\n     * @return Boolean to indicate if the operation was successful or not.\n     */\n    function setManager(address _newManager) external onlyOwner returns (bool) {\n        return _setManager(_newManager);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Set or change of manager.\n     * @param _newManager New _manager address.\n     * @return Boolean to indicate if the operation was successful or not.\n     */\n    function _setManager(address _newManager) private returns (bool) {\n        address _previousManager = _manager;\n\n        require(_newManager != _previousManager, \"Manageable/existing-manager-address\");\n\n        _manager = _newManager;\n\n        emit ManagerTransferred(_previousManager, _newManager);\n        return true;\n    }\n\n    /* ============ Modifier Functions ============ */\n\n    /**\n     * @dev Throws if called by any account other than the manager.\n     */\n    modifier onlyManager() {\n        require(manager() == msg.sender, \"Manageable/caller-not-manager\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the manager or the owner.\n     */\n    modifier onlyManagerOrOwner() {\n        require(manager() == msg.sender || owner() == msg.sender, \"Manageable/caller-not-manager-or-owner\");\n        _;\n    }\n}\n"
    },
    "@pooltogether/owner-manager-contracts/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\n/**\n * @title Abstract ownable contract that can be inherited by other contracts\n * @notice Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner is the deployer of the contract.\n *\n * The owner account is set through a two steps process.\n *      1. The current `owner` calls {transferOwnership} to set a `pendingOwner`\n *      2. The `pendingOwner` calls {acceptOwnership} to accept the ownership transfer\n *\n * The manager account needs to be set using {setManager}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n    address private _pendingOwner;\n\n    /**\n     * @dev Emitted when `_pendingOwner` has been changed.\n     * @param pendingOwner new `_pendingOwner` address.\n     */\n    event OwnershipOffered(address indexed pendingOwner);\n\n    /**\n     * @dev Emitted when `_owner` has been changed.\n     * @param previousOwner previous `_owner` address.\n     * @param newOwner new `_owner` address.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /* ============ Deploy ============ */\n\n    /**\n     * @notice Initializes the contract setting `_initialOwner` as the initial owner.\n     * @param _initialOwner Initial owner of the contract.\n     */\n    constructor(address _initialOwner) {\n        _setOwner(_initialOwner);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Gets current `_pendingOwner`.\n     * @return Current `_pendingOwner` address.\n     */\n    function pendingOwner() external view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @notice Renounce ownership of the contract.\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n    * @notice Allows current owner to set the `_pendingOwner` address.\n    * @param _newOwner Address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Ownable/pendingOwner-not-zero-address\");\n\n        _pendingOwner = _newOwner;\n\n        emit OwnershipOffered(_newOwner);\n    }\n\n    /**\n    * @notice Allows the `_pendingOwner` address to finalize the transfer.\n    * @dev This function is only callable by the `_pendingOwner`.\n    */\n    function claimOwnership() external onlyPendingOwner {\n        _setOwner(_pendingOwner);\n        _pendingOwner = address(0);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Internal function to set the `_owner` of the contract.\n     * @param _newOwner New `_owner` address.\n     */\n    function _setOwner(address _newOwner) private {\n        address _oldOwner = _owner;\n        _owner = _newOwner;\n        emit OwnershipTransferred(_oldOwner, _newOwner);\n    }\n\n    /* ============ Modifier Functions ============ */\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable/caller-not-owner\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the `pendingOwner`.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == _pendingOwner, \"Ownable/caller-not-pendingOwner\");\n        _;\n    }\n}\n"
    },
    "contracts/RNGBlockhash.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./RNGInterface.sol\";\n\ncontract RNGBlockhash is RNGInterface, Ownable {\n  /// @dev A counter for the number of requests made used for request ids\n  uint32 internal requestCount;\n\n  /// @dev A list of random numbers from past requests mapped by request id\n  mapping(uint32 => uint256) internal randomNumbers;\n\n  /// @dev A list of blocks to be locked at based on past requests mapped by request id\n  mapping(uint32 => uint32) internal requestLockBlock;\n\n  /// @notice Gets the last request id used by the RNG service\n  /// @return requestId The last request id used in the last request\n  function getLastRequestId() external view override returns (uint32 requestId) {\n    return requestCount;\n  }\n\n  /// @notice Gets the Fee for making a Request against an RNG service\n  /// @return feeToken The address of the token that is used to pay fees\n  /// @return requestFee The fee required to be paid to make a request\n  function getRequestFee() external pure override returns (address feeToken, uint256 requestFee) {\n    return (address(0), 0);\n  }\n\n  /// @notice Sends a request for a random number to the 3rd-party service\n  /// @dev Some services will complete the request immediately, others may have a time-delay\n  /// @dev Some services require payment in the form of a token, such as $LINK for Chainlink VRF\n  /// @return requestId The ID of the request used to get the results of the RNG service\n  /// @return lockBlock The block number at which the RNG service will start generating time-delayed randomness.  The calling contract\n  /// should \"lock\" all activity until the result is available via the `requestId`\n  function requestRandomNumber()\n    external\n    virtual\n    override\n    returns (uint32 requestId, uint32 lockBlock)\n  {\n    requestId = _getNextRequestId();\n    lockBlock = uint32(block.number);\n\n    requestLockBlock[requestId] = lockBlock;\n\n    emit RandomNumberRequested(requestId, msg.sender);\n  }\n\n  /// @notice Checks if the request for randomness from the 3rd-party service has completed\n  /// @dev For time-delayed requests, this function is used to check/confirm completion\n  /// @param requestId The ID of the request used to get the results of the RNG service\n  /// @return isCompleted True if the request has completed and a random number is available, false otherwise\n  function isRequestComplete(uint32 requestId)\n    external\n    view\n    virtual\n    override\n    returns (bool isCompleted)\n  {\n    return _isRequestComplete(requestId);\n  }\n\n  /// @notice Gets the random number produced by the 3rd-party service\n  /// @param requestId The ID of the request used to get the results of the RNG service\n  /// @return randomNum The random number\n  function randomNumber(uint32 requestId) external virtual override returns (uint256 randomNum) {\n    require(_isRequestComplete(requestId), \"RNGBlockhash/request-incomplete\");\n\n    if (randomNumbers[requestId] == 0) {\n      _storeResult(requestId, _getSeed());\n    }\n\n    return randomNumbers[requestId];\n  }\n\n  /// @dev Checks if the request for randomness from the 3rd-party service has completed\n  /// @param requestId The ID of the request used to get the results of the RNG service\n  /// @return True if the request has completed and a random number is available, false otherwise\n  function _isRequestComplete(uint32 requestId) internal view returns (bool) {\n    return block.number > (requestLockBlock[requestId] + 1);\n  }\n\n  /// @dev Gets the next consecutive request ID to be used\n  /// @return requestId The ID to be used for the next request\n  function _getNextRequestId() internal returns (uint32 requestId) {\n    requestCount++;\n    requestId = requestCount;\n  }\n\n  /// @dev Gets a seed for a random number from the latest available blockhash\n  /// @return seed The seed to be used for generating a random number\n  function _getSeed() internal view virtual returns (uint256 seed) {\n    return uint256(blockhash(block.number - 1));\n  }\n\n  /// @dev Stores the latest random number by request ID and logs the event\n  /// @param requestId The ID of the request to store the random number\n  /// @param result The random number for the request ID\n  function _storeResult(uint32 requestId, uint256 result) internal {\n    // Store random value\n    randomNumbers[requestId] = result;\n\n    emit RandomNumberCompleted(requestId, result);\n  }\n}\n"
    },
    "contracts/Oracle.sol": {
      "content": "pragma solidity ^0.8.0;\nimport \"./RNGInterface.sol\";\n\ncontract Oracle {\n    RNGInterface public _randomNumbers;\n    constructor()  {\n        address  randomService = 0x1cDC2A4fF8d374D91a1161C142cc496FBF5547Ec;\n        _randomNumbers = RNGInterface(randomService);\n    }\n\n    function requestRandomNumber() external returns (uint32 requestId, uint32 lockBlock){\n        return  _randomNumbers.requestRandomNumber();\n    }\n\n    function getEventResult(uint256 eventId) external returns (uint8) {\n        //(uint32 requestId,)  = _randomNumbers.requestRandomNumber();\n       // uint256 randomNumber = _randomNumbers.randomNumber(requestId);\n       // uint256 result = randomNumber % 3;\n        return 2;\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}